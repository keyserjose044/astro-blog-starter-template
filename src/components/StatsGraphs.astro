---
const API_URL =
  "https://script.google.com/macros/s/AKfycbw2o8bsw-UGn-qizyftLnuFSUwqR_5RITxhmqkBBCS9YoGkMhIsx97wkzUtv99DoNBJsw/exec";

const metrics = [
  { key: "guitar", label: "Guitar Hours", icon: "üé∏" },
  { key: "audiobooks", label: "Audiobook Hours", icon: "üìö" },
  { key: "running", label: "Miles Ran", icon: "üèÉ‚Äç‚ôÇÔ∏è" },
  { key: "diary", label: "Average Diary Words", icon: "üìì" },
  { key: "music", label: "Music Hours", icon: "üéµ" },
];

const YEAR_COLORS = [
  "#2563eb", // bright blue
  "#f97316", // orange
  "#22c55e", // green
  "#e11d48", // red
  "#a855f7", // purple
  "#14b8a6", // teal
  "#facc15", // yellow
  "#64748b", // slate
];

const defaultMetricKey = "guitar";
---

<section
  id="graphs"
  class="section"
  aria-labelledby="graphs-heading"
>
  <h2 id="graphs-heading">üìà Detailed Stat Graphs</h2>
  <p class="section-hint">
    Explore how key stats evolve over time. Toggle between metrics and years, powered by your Archive sheet.
  </p>

  <!-- Metric tabs -->
  <div class="metrics-tabs" id="metrics-tabs">
    {metrics.map((m) => (
      <button
        type="button"
        class={`metrics-tab ${
          m.key === defaultMetricKey ? "metrics-tab--active" : ""
        }`}
        data-metric={m.key}
      >
        <span class="metrics-tab__icon">{m.icon}</span>
        <span class="metrics-tab__label">{m.label}</span>
      </button>
    ))}
  </div>

  <div class="graph-card">
    <div class="graph-card__header">
      <div class="graph-card__title">
        <span id="graph-title-icon">üé∏</span>
        <span id="graph-title-text">Guitar Hours by Month</span>
      </div>

      <div class="graph-card__controls">
        <label class="graph-card__control">
          <span>Year</span>
          <select id="guitar-year-select"></select>
        </label>
      </div>
    </div>

    <div class="graph-card__body">
      <p id="guitar-year-total" class="graph-card__year-total">
        <!-- filled by JS -->
      </p>
      <div id="guitar-chart" class="graph-card__chart">
        <div class="graph-card__fallback">
          Loading chart‚Ä¶
        </div>
      </div>
    </div>
  </div>

  <!-- D3 from CDN -->
  <script
    src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"
    defer
  ></script>

  <!-- Client-side script to fetch data + draw chart -->
  <script>
    (function () {
      const API_URL =
        "https://script.google.com/macros/s/AKfycbw2o8bsw-UGn-qizyftLnuFSUwqR_5RITxhmqkBBCS9YoGkMhIsx97wkzUtv99DoNBJsw/exec";

      const CURRENT_YEAR = new Date().getFullYear();  // ‚¨ÖÔ∏è add this

      const monthOrder = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ];

      // Metric config for JS (units + labels)
      const METRICS = {
        guitar: {
          label: "Guitar Hours by Month",
          icon: "üé∏",
          unit: "hours",
        },
        running: {
          label: "Miles Ran by Month",
          icon: "üèÉ‚Äç‚ôÇÔ∏è",
          unit: "miles",
        },
        diary: {
          label: "Average Diary Words by Month",
          icon: "üìì",
          unit: "words/day",
        },
        music: {
          label: "Music Hours by Month",
          icon: "üéµ",
          unit: "hours",
        },
        audiobooks: {
          label: "Audiobook Hours by Month",
          icon: "üìö",
          unit: "hours",
        },
      };

      function scrollToGraphsIfRequested() {
        if (window.location.hash === "#graphs") {
          const target = document.getElementById("graphs");
          if (!target) return;
          setTimeout(() => {
            target.scrollIntoView({ behavior: "smooth", block: "start" });
          }, 150);
        }
      }

      function getInitialFromUrl(METRICS, CURRENT_YEAR) {
        const params = new URLSearchParams(window.location.search || "");
        const metricParam = (params.get("metric") || "").toLowerCase();
        const yearParam = params.get("year") || "";
      
        const metric = METRICS[metricParam] ? metricParam : "guitar";
      
        let year = null;
        if (yearParam === "current") year = CURRENT_YEAR;
        else if (yearParam && !Number.isNaN(Number(yearParam))) year = Number(yearParam);
      
        return { metric, year };
      }

      function whenReady(fn) {
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", fn);
        } else {
          fn();
        }
      }

      whenReady(() => {
        scrollToGraphsIfRequested(); // ‚úÖ add this line

        function start() {
          const d3 = window.d3;
          const container = document.getElementById("guitar-chart");
          const select = document.getElementById("guitar-year-select");
          const tabsContainer = document.getElementById("metrics-tabs");

          if (!d3 || !container || !select || !tabsContainer) {
            return setTimeout(start, 50);
          }

          initChart(d3, container, select, tabsContainer);
        }

        start();
      });

      async function initChart(d3, container, select, tabsContainer) {
        // show skeleton immediately
        container.innerHTML =
          '<div class="chart-skeleton" aria-hidden="true"></div>';

        let rawData;

        try {
          const res = await fetch(API_URL);
          rawData = await res.json();
        } catch (err) {
          console.error("Error fetching graph data:", err);
          container.innerHTML =
            '<div class="graph-card__fallback">Error loading data from GAS.</div>';
          return;
        }

        if (!Array.isArray(rawData)) {
          rawData = Object.values(rawData || {});
        }

        // Normalize everything into a single array ‚Äì we keep ALL metrics here
        const allData = (Array.isArray(rawData) ? rawData : Object.values(rawData || {}))
          .map((d) => ({
            metric: String(d.metric || "").toLowerCase(), // 'guitar', 'running', etc.
            year: Number(d.year),
            month: String(d.month),
            value: Number(d.value) || 0,
          }))
          .filter((d) => d.metric && d.year && d.month);
        
        if (!allData.length) {
          console.warn("No data points found:", rawData);
          container.innerHTML =
            '<div class="graph-card__fallback">No data found.</div>';
          return;
        }
        
        const initial = getInitialFromUrl(METRICS, CURRENT_YEAR);
        
        let activeMetricKey = initial.metric;   // ‚úÖ from URL (e.g., audiobooks)
        let currentYear = null;                 // set by updateYearOptions()
        
        const titleText = document.getElementById("graph-title-text");
        const titleIcon = document.getElementById("graph-title-icon");
        const totalEl   = document.getElementById("guitar-year-total");
      
        function getYearsForMetric(metricKey) {
          return Array.from(
            new Set(
              allData
                .filter((d) => d.metric === metricKey && d.year <= CURRENT_YEAR)
                .map((d) => d.year)
            )
          ).sort((a, b) => a - b);
        }

        function updateTitle(metricKey) {
          const cfg = METRICS[metricKey] || METRICS.guitar;
          if (titleText) titleText.textContent = cfg.label;
          if (titleIcon) titleIcon.textContent = cfg.icon;
        }
      
        function updateYearOptions(metricKey) {
          const years = getYearsForMetric(metricKey);
        
          if (!years.length) {
            select.innerHTML = "";
            container.innerHTML =
              '<div class="graph-card__fallback">No data for this metric.</div>';
            currentYear = null;
            return;
          }
        
          // üëá Add "All years" before the numeric options
          select.innerHTML =
            `<option value="all">All years</option>` +
            years.map((y) => `<option value="${y}">${y}</option>`).join("");
        
          // URL override ‚Üí current year ‚Üí fallback
          if (initial.year && years.includes(initial.year)) {
            currentYear = initial.year;
          } else if (years.includes(CURRENT_YEAR)) {
            currentYear = CURRENT_YEAR;
          } else {
            currentYear = years[years.length - 1];
          }
        
          select.value = String(currentYear);
        }

        function drawCurrent() {
          if (!activeMetricKey) return;
        
          if (currentYear === null) {
            // All years overlay
            drawChartAllYears(activeMetricKey, allData, container, d3);
          } else {
            // Single year (existing behavior)
            drawChart(activeMetricKey, currentYear, allData, container, d3);
          }
        }

        // Year dropdown
        select.addEventListener("change", () => {
          const val = select.value;
          currentYear = (val === "all") ? null : Number(val);
          drawCurrent();
        });
        
        // Metric tabs
        const tabButtons = Array.from(
          tabsContainer.querySelectorAll("[data-metric]")
        );

        tabButtons.forEach((b) => {
          b.classList.toggle(
            "metrics-tab--active",
            b.getAttribute("data-metric") === activeMetricKey
          );
        });

        tabButtons.forEach((btn) => {
          btn.addEventListener("click", () => {
            const metricKey = btn.getAttribute("data-metric");
            if (!metricKey || metricKey === activeMetricKey) return;
        
            activeMetricKey = metricKey;
        
            tabButtons.forEach((b) =>
              b.classList.toggle("metrics-tab--active", b === btn)
            );
        
            updateTitle(activeMetricKey);
            updateYearOptions(activeMetricKey);
            drawCurrent();
          });
        });
        
        // Initial render
        updateTitle(activeMetricKey);
        updateYearOptions(activeMetricKey);
        drawCurrent();
        
        // Resize should respect current mode (single year / all years)
        window.addEventListener("resize", () => {
          drawCurrent();
        }
        ); // end initChart
        
        function drawChart(metricKey, year, data, container, d3) {
          const cfg = METRICS[metricKey] || METRICS.guitar;
        
          const yearData = monthOrder.map((m) => {
            const match = data.find(
              (d) => d.metric === metricKey && d.year === year && d.month === m
            );
            const raw = match ? match.value : 0;
            const value = Math.round(raw);
            return { month: m, value };
          });
        
          let totalValue;
        
          // Diary uses the AVERAGE of the 12 monthly averages
          if (metricKey === "diary") {
            const vals = yearData.map((d) => d.value);
            const valid = vals.filter((v) => v > 0);
            totalValue = valid.length
              ? Math.round(valid.reduce((s, v) => s + v, 0) / valid.length)
              : 0;
          } else {
            // Other metrics use the sum
            totalValue = yearData.reduce((sum, d) => sum + d.value, 0);
          }
        
          const totalEl = document.getElementById("guitar-year-total");
          if (totalEl) {
            totalEl.innerHTML = `
              <span class="year-label"><strong>${year}</strong> total:</span>
              <span class="graph-pill">${totalValue} ${cfg.unit}</span>
            `;
          }
        
          const margin = { top: 24, right: 24, bottom: 40, left: 48 };
          const width = container.clientWidth || 800;
          const height = 360;
        
          container.innerHTML = "";
        
          const svg = d3
            .select(container)
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("overflow", "visible");
        
          // ----------- SMART X SCALE (reduced whitespace) -----------
          const x = d3
            .scalePoint()
            .domain(monthOrder)
            .range([margin.left, width - margin.right])
            .padding(0.15);
        
          // ----------- SMART Y SCALE (adaptive to metric type) -----------
          const maxY = d3.max(yearData, (d) => d.value) || 1;
        
          let step;
          if (maxY <= 10) step = 1;
          else if (maxY <= 50) step = 5;
          else if (maxY <= 100) step = 10;
          else if (maxY <= 500) step = 50;
          else if (maxY <= 1000) step = 100;
          else step = 250;
        
          const niceMaxY = Math.ceil(maxY / step) * step;
        
          const y = d3
            .scaleLinear()
            .domain([0, niceMaxY])
            .nice()
            .range([height - margin.bottom, margin.top]);
        
          // ----------- X AXIS -----------
          const xAxis = (g) =>
            g
              .attr("transform", `translate(0,${height - margin.bottom})`)
              .call(d3.axisBottom(x).tickSizeOuter(0))
              .selectAll("text")
              .style("font-size", "12px")
              .style("fill", "#111827");
        
          // ----------- Y AXIS -----------
          const yAxis = (g) =>
            g
              .attr("transform", `translate(${margin.left},0)`)
              .call(d3.axisLeft(y).ticks(6))
              .call((g2) => {
                g2.select(".domain").remove();
                g2
                  .append("line")
                  .attr("x1", 0)
                  .attr("x2", 0)
                  .attr("y1", y(0))
                  .attr("y2", y(niceMaxY))
                  .attr("stroke", "#6b7280")
                  .attr("stroke-width", 1.25);
              })
              .selectAll("text")
              .style("font-size", "12px")
              .style("fill", "#111827");
        
          svg.append("g").call(xAxis);
          svg.append("g").call(yAxis);
        
          const line = d3
            .line()
            .x((d) => x(d.month))
            .y((d) => y(d.value))
            .curve(d3.curveMonotoneX);
        
          const area = d3
            .area()
            .x((d) => x(d.month))
            .y0(y(0))
            .y1((d) => y(d.value))
            .curve(d3.curveMonotoneX);
        
          svg
            .append("path")
            .datum(yearData)
            .attr("fill", "rgba(59, 130, 246, 0.12)")
            .attr("d", area);
        
          svg
            .append("path")
            .datum(yearData)
            .attr("fill", "none")
            .attr("stroke", "#2563eb")
            .attr("stroke-width", 2.5)
            .attr("d", line);
        
          const points = svg
            .selectAll(".point")
            .data(yearData)
            .enter()
            .append("g")
            .attr("class", "point");
        
          points
            .append("circle")
            .attr("cx", (d) => x(d.month))
            .attr("cy", (d) => y(d.value))
            .attr("r", 4)
            .attr("fill", "#2563eb");
        
          points
            .append("text")
            .attr("x", (d) => x(d.month))
            .attr("y", (d) => y(d.value) - 8)
            .attr("text-anchor", "middle")
            .style("font-size", "11px")
            .style("fill", "#111827")
            .text((d) => d.value);
        }
        
        
        function drawChartAllYears(metricKey, data, container, d3) {
          const cfg = METRICS[metricKey] || METRICS.guitar;
        
          // Filter to this metric only
          const metricData = data.filter((d) => d.metric === metricKey);
        
          // Unique years for this metric
          const years = Array.from(
            new Set(metricData.map((d) => d.year).filter(Boolean))
          ).sort((a, b) => a - b);
        
          if (!years.length) {
            container.innerHTML =
              '<div class="graph-card__fallback">No data for this metric.</div>';
            const totalEl = document.getElementById("guitar-year-total");
            if (totalEl) {
              totalEl.innerHTML =
                '<span class="year-label"><strong>All years</strong> total:</span>' +
                '<span class="graph-pill">No data</span>';
            }
            return;
          }
        
          // Build series: one array of {month, value} per year
          const seriesByYear = years.map((year) => {
            const values = monthOrder.map((m) => {
              const match = metricData.find(
                (d) => d.year === year && d.month === m
              );
              const raw = match ? match.value : 0;
              const value = Math.round(raw);
              return { month: m, value };
            });
            return { year, values };
          });
        
          // Flatten all values to compute y-scale
          const flatValues = seriesByYear.flatMap((s) =>
            s.values.map((v) => v.value)
          );
          const maxY = flatValues.length ? Math.max(...flatValues) : 1;
        
          let step;
          if (maxY <= 10) step = 1;
          else if (maxY <= 50) step = 5;
          else if (maxY <= 100) step = 10;
          else if (maxY <= 500) step = 50;
          else if (maxY <= 1000) step = 100;
          else step = 250;
        
          const niceMaxY = Math.ceil(maxY / step) * step;
        
          // Update total line for "All years"
          const totalEl = document.getElementById("guitar-year-total");
          if (totalEl) {
            let totalValue;
        
            if (metricKey === "diary") {
              // Average across all non-zero monthly diary values
              const vals = flatValues.filter((v) => v > 0);
              totalValue = vals.length
                ? Math.round(vals.reduce((s, v) => s + v, 0) / vals.length)
                : 0;
            } else {
              // Sum across all years
              totalValue = flatValues.reduce((s, v) => s + v, 0);
            }
        
            totalEl.innerHTML = `
              <span class="year-label"><strong>All years</strong> total:</span>
              <span class="graph-pill">${totalValue} ${cfg.unit}</span>
            `;
          }
        
          const margin = { top: 24, right: 24, bottom: 40, left: 48 };
          const width = container.clientWidth || 800;
          const height = 360;
        
          container.innerHTML = "";
        
          const svg = d3
            .select(container)
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("overflow", "visible");
        
          // Same x-scale as single-year chart
          const x = d3
            .scalePoint()
            .domain(monthOrder)
            .range([margin.left, width - margin.right])
            .padding(0.15);
        
          const y = d3
            .scaleLinear()
            .domain([0, niceMaxY])
            .nice()
            .range([height - margin.bottom, margin.top]);
        
          // X axis
          const xAxis = (g) =>
            g
              .attr("transform", `translate(0,${height - margin.bottom})`)
              .call(d3.axisBottom(x).tickSizeOuter(0))
              .selectAll("text")
              .style("font-size", "12px")
              .style("fill", "#111827");
        
          // Y axis
          const yAxis = (g) =>
            g
              .attr("transform", `translate(${margin.left},0)`)
              .call(d3.axisLeft(y).ticks(6))
              .call((g2) => {
                g2.select(".domain").remove();
                g2
                  .append("line")
                  .attr("x1", 0)
                  .attr("x2", 0)
                  .attr("y1", y(0))
                  .attr("y2", y(niceMaxY))
                  .attr("stroke", "#6b7280")
                  .attr("stroke-width", 1.25);
              })
              .selectAll("text")
              .style("font-size", "12px")
              .style("fill", "#111827");
        
          svg.append("g").call(xAxis);
          svg.append("g").call(yAxis);
        
          const line = d3
            .line()
            .x((d) => x(d.month))
            .y((d) => y(d.value))
            .curve(d3.curveMonotoneX);
        
          // Draw one line per year with varying opacity / hue
          seriesByYear.forEach((series, idx) => {
            const color = YEAR_COLORS[idx % YEAR_COLORS.length];
          
            svg
              .append("path")
              .datum(series.values)
              .attr("fill", "none")
              .attr("stroke", color)
              .attr("stroke-width", 2)
              .attr("opacity", 0.95)
              .attr("d", line);
          });

      
          // Simple legend (year labels) in the top-right corner
          const legend = svg
            .append("g")
            .attr("transform", `translate(${width - margin.right - 80}, ${margin.top})`);

          seriesByYear.forEach((series, idx) => {
            const color = YEAR_COLORS[idx % YEAR_COLORS.length];
          
            const row = legend
              .append("g")
              .attr("transform", `translate(0, ${idx * 16})`);
          
            row
              .append("line")
              .attr("x1", 0)
              .attr("x2", 16)
              .attr("y1", 6)
              .attr("y2", 6)
              .attr("stroke", color)
              .attr("stroke-width", 2);
          
            row
              .append("text")
              .attr("x", 20)
              .attr("y", 9)
              .attr("font-size", 11)
              .attr("fill", "#111827")
              .text(series.year);
          });

        // ----------- SMART X SCALE (reduced whitespace) -----------
        const x = d3
          .scalePoint()
          .domain(monthOrder)
          .range([margin.left, width - margin.right])
          .padding(0.15);  // was 0.5
        
        // ----------- SMART Y SCALE (adaptive to metric type) -----------
        const maxY = d3.max(yearData, (d) => d.value) || 1;
        
        let step;
        if (maxY <= 10)      step = 1;
        else if (maxY <= 50) step = 5;
        else if (maxY <= 100) step = 10;
        else if (maxY <= 500) step = 50;
        else if (maxY <= 1000) step = 100;
        else step = 250;
        
        const niceMaxY = Math.ceil(maxY / step) * step;
        
        const y = d3
          .scaleLinear()
          .domain([0, niceMaxY])
          .nice()
          .range([height - margin.bottom, margin.top]);
        
        // ----------- X AXIS -----------
        const xAxis = (g) =>
          g
            .attr("transform", `translate(0,${height - margin.bottom})`)
            .call(d3.axisBottom(x).tickSizeOuter(0))
            .selectAll("text")
            .style("font-size", "12px")
            .style("fill", "#111827");
        
        // ----------- Y AXIS -----------
        const yAxis = (g) =>
          g
            .attr("transform", `translate(${margin.left},0)`)
            .call(d3.axisLeft(y).ticks(6))
            .call((g2) => {
              g2.select(".domain").remove(); // remove default axis
              g2.append("line")              // custom left border
                .attr("x1", 0)
                .attr("x2", 0)
                .attr("y1", y(0))
                .attr("y2", y(niceMaxY))
                .attr("stroke", "#6b7280")
                .attr("stroke-width", 1.25);
            })
            .selectAll("text")
            .style("font-size", "12px")
            .style("fill", "#111827");


        svg.append("g").call(xAxis);
        svg.append("g").call(yAxis);

        const line = d3
          .line()
          .x((d) => x(d.month))
          .y((d) => y(d.value))
          .curve(d3.curveMonotoneX);

        const area = d3
          .area()
          .x((d) => x(d.month))
          .y0(y(0))
          .y1((d) => y(d.value))
          .curve(d3.curveMonotoneX);

        svg
          .append("path")
          .datum(yearData)
          .attr("fill", "rgba(59, 130, 246, 0.12)")
          .attr("d", area);

        svg
          .append("path")
          .datum(yearData)
          .attr("fill", "none")
          .attr("stroke", "#2563eb")
          .attr("stroke-width", 2.5)
          .attr("d", line);

        const points = svg
          .selectAll(".point")
          .data(yearData)
          .enter()
          .append("g")
          .attr("class", "point");

        points
          .append("circle")
          .attr("cx", (d) => x(d.month))
          .attr("cy", (d) => y(d.value))
          .attr("r", 4)
          .attr("fill", "#2563eb");

        points
          .append("text")
          .attr("x", (d) => x(d.month))
          .attr("y", (d) => y(d.value) - 8)
          .attr("text-anchor", "middle")
          .style("font-size", "11px")
          .style("fill", "#111827")
          .text((d) => d.value);
      }
    })();
  </script>

  <style>
    .metrics-tabs {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 2rem;
    }

    .metrics-tab {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.45rem 0.9rem;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #ffffff;
      color: #4b5563;
      font-size: 0.9rem;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.06);
      transition:
        background 0.15s ease,
        color 0.15s ease,
        border-color 0.15s ease,
        box-shadow 0.15s ease,
        transform 0.1s ease;
    }

    .metrics-tab__icon {
      font-size: 1rem;
    }

    .metrics-tab--active {
      background: #111827;
      color: #f9fafb;
      border-color: #111827;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.3);
      transform: translateY(-1px);
    }

    .metrics-tab:hover:not(.metrics-tab--active) {
      background: #f9fafb;
      border-color: #d1d5db;
    }

    .graph-card {
      margin-top: 2rem;
      padding: 1.5rem;
      border-radius: 1rem;
      background: #ffffff;
      border: 1px solid #e5e7eb;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.12);
    }

    .graph-card__header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.75rem;
      color: #111827;
    }

    .graph-card__title {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .graph-card__controls {
      margin-left: auto;
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }

    .graph-card__control {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
    }

    .graph-card__control select {
      border-radius: 999px;
      padding: 6px 12px;
      border: 1px solid #cbd5e1;
      background: #ffffff;
      color: #1e293b;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease;
    }

    .graph-card__control select:hover {
      background: #f1f5f9;
      border-color: #94a3b8;
    }

    .graph-card__control select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px #3b82f6;
    }

    .graph-card__body {
      margin-top: 0.5rem;
    }

    .graph-card__chart {
      width: 100%;
      min-height: 260px;
    }

    /* üî• Unified + enlarged year total line */
    .graph-card__year-total {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 0.8rem;

      font-size: 1.1rem;
      color: #111827;
      font-weight: 600;
    }

    .graph-card__year-total strong {
      color: #111827;
      font-weight: 700;
    }

    .chart-skeleton {
      width: 100%;
      height: 260px;
      background: linear-gradient(
        90deg,
        #f1f5f9 0%,
        #e2e8f0 50%,
        #f1f5f9 100%
      );
      background-size: 200% 100%;
      border-radius: 0.5rem;
      animation: skeleton-shimmer 1.25s infinite;
      margin-top: 1rem;
    }

    @keyframes skeleton-shimmer {
      0% {
        background-position: 200% 0;
      }
      100% {
        background-position: -200% 0;
      }
    }

    @media (max-width: 640px) {
      .graph-card {
        padding: 1.25rem;
      }

      .graph-card__controls {
        margin-left: 0;
      }

      .metrics-tabs {
        margin-top: 1.5rem;
      }
    }
  </style>
</section>

  
